title: 链表（LinkedList）
id: 1504768830922
author: 不识
tags:
  - 链表
categories:
  - 数据结构
date: 2017-09-07 15:20:00
---
***
# 简介
***
链表是由一组顶点（节点）组成的数据结构，它们一起表示一个序列。在最简单的形式，每个顶点由数据和序列中下一个顶点的引用（链接）组成。链表及其变体用作底层数据结构来实现**List**，**Stack**，**Queue**和**Deque**等ADT。

链表数据结构是计算机科学（CS）本科最常教授的课程，原因如下： 
1. 它是一个简单的线性数据结构
2. 作为list ADT它有一系列潜在的应用，例如学生列表，事件列表，约会列表等（尽管还有其他更高级的数据结构可以更好地执行相同的应用程序），或作为以及stack/queue/ deque ADT
3. 它有一些有趣的极端/特殊情况来说明一个好的数据结构实现的需要
4. 它具有各种自定义选项，因此通常使用面向对象编程（OOP）方式教导链表数据结构使用。

<!-- more -->
## List ADT
***
 List是系列的items/date ，它们位置有序{a0，a1，...，aN-2，aN-1}。 通常的List ADT操作有：
1. **get(i)** — 可能是一个微不足道的操作，返回ai（基于0的索引），
2. **search(v) **— 决定item/data在list中是否存在，存在的话报告它的位置/索引，不存在通常返回索引-1
3. **insert(i,v)** — 在list中向指定的位置/索引插入item/data v，可能需要将item从之前的位置：[i..N-1]，移动到它们右边的一个位置，
4. **remove(i)** — 删除list中特定于位置/索引为i的item，可能会将之前位置的item[i + 1..N-1]向左移动一个位置，以关闭空格。

## 数组实现
***
（紧凑）数组是实现List ADT的一个好的选择，因为它是处理集合的一个简单的构造。

当我们说**紧凑数组**（Compact Array），这意味着一个没有空隔的数组，也就是如果有N个item在数组（它的大小为M，并且M≥N）中，那么只有索引[0..N-1]处被占据，而其他的索引[N..M-1] 依旧为空
![紧凑数组](\images\datastructure\compactarray_illustration.png)

### 通用操作
一个紧凑数组名称为A，索引[0..N-1]处为list中的item。 

- get(i)，只是返回A [i]。 如果不是紧凑数组，这个简单的操作将不必要地复杂化。
- search(v)，我们逐一检查每个索引i∈[0..N-1]以查看是否A [i] == v。v，如果存在，可以在索引[0..N-1]中的任何位置。
- insert(i，v)，我们将item∈[i..N-1]移位到[i + 1..N]（从后向），并设置A [i] = v。这是为了使v在索引i处正确插入并保持紧凑性。 
- remove(i)，我们将项∈[i + 1..N-1]移动到[i..N-2]，覆盖旧的A [i]。 这是为了保持紧凑性。

### 时间复杂度

- get(i)非常快：只有一个访问，O（1）。 
- search(v)
在最好的情况下，v在第一个位置找到,O（1）。
在最坏的情况下，列表中找不到v，我们需要扫描来确定,O（N）。
- insert(i，v)
在最好的情况下，在i = N处插入，不需要移动元素，O（1）。 
在最坏的情况下，在i = 0处插入，我们将所有N个元素移位，O（N）。 
- remove(i)
在最好的情况下，在i = N-1处删除，不需要移动元素，O（1）。
在最坏的情况下，在i = 0处删除，我们将所有N个元素移位，O（N）。
 
### 固定大小问题
紧凑数组的大戏M不是无限的，而是一个有限的数组。这暴露出一个问题，在许多应用程序中最大大小可能是未知的。
如果M太大的话，会有很多空间被浪费，如果M太小的话，很容易耗尽空间。
解决方法是让M是一个变量。这样当数据满的时候，我们创建一个更大的数组，并且将元素从旧数组移动到新数组中。因此，除了（通常较大的）物理计算机存储器大小限制之外的没有其他的尺寸限制，此类实现如， C ++ STL vector，Java Vector或Java ArrayList。然而，空间浪费和复制/转移item开支的问题仍然存在问题。
 
对于固定大小的集合，具有已知最大限制的item数量，即M的最大值，则数组已经是List ADT实现的相当好的数据结构。
对于尺寸变化的集合，它的大小M未知，并且一些动态操作如insert/remove相当平常，一个简单的数据实际上是一个数据结构的糟糕选择。对于这样的应用程序，有更好的数据结构。

*** 
# Linked List(LL)
***
现在我们引入链表数据结构。它使用指针来允许item/data在内存中不连续（这与简单数组的主要区别）。它将item从索引0到索引N-1排序，通过指针将item i与其相邻item i + 1相关联。
![链表](\images\datastructure\ll_illustration.png)
在最基本的形式中，链接列表中的单个顶点（节点）具有以下结构：
```java
struct or class Vertex { //我们同时使用 C++ struct/(Java) class
  int item// 数据存储在这里，本例中是整数
  Vertex *next // 这个指针告诉我们下一个顶点的位置
}
```
在链表数据结构中还有一些我们需要记住的额外数据。
- **head**指针指向a<sub>0</sub>
- **tail**指针指向a<sub>N-1</sub>

就是这样,我们只添加两个额外的变量的数据结构。

## Get(i)——比数组慢很多
***
由于我们只保留头尾指针，所以需要列表遍历的方法来达到head（索引0）和tail（索引N-1）以外的位置。由于这个遍历需要频繁使用，我们将它抽象为一个方法
```java
Vertex Get(int i) { // 返回该顶点
  Vertex ptr = head //从head部开始
  for (int k = 0; k < i; k++) // 向后移动i 次
    ptr = ptr.next //指针指向后一个的索引
  return ptr
}
```
它运行在O（N），因为i可能等于索引N-2。
与数组相比，数组可以在O（1）时间访问索引i。

## Search(i)——不比数组快
***
由于我们只直接引用第一个head和最后一个tail，加上指针指向右侧（较高位置/索引），我们只能通过从头项目开始并通过下一个指针来访问其余部分。例子：

## Insert(i，v)
***
由于链表的性质，它有比数组更多的情况，对于insert(i, v)，有四种（合法）的可能性，也就是v插入到：
1. 链表的头部（在当前第一个item之前），i=0
2. 一个空的链表（幸运的是类似于前面的情况）
3. 链表最后一个item（当前的tail）之后的位置，i=N
4. 链表的其他位置，i = [1..N-1].

### 插入到头部
插入头部的伪代码简单而高效，时间复杂度为O（1）：
```java
Vertex vtx = new Vertex(v) //从item v创建一个新的Vertex vtx
vtx.next = head // 将这个新的顶点链接到 (旧的) head顶点上
head = vtx //该新的顶点变为新的head
```
### 插入到空的链表
空数据结构是一个常见的极端/特殊情况，如果未正确测试，可能会导致意外的崩溃。将新item插入到当前空的列表中，即索引i = 0处是合法的。幸运的是，用于插入到head的伪代码同样适用于一个空的list。
```java
Vertex vtx = new Vertex(v) //从item v创建一个新的Vertex vtx
vtx.next = head // 之前head为null，所以vtx.next保持为null
head = vtx //该新的顶点变为新的head
```
### 插入到链表之间
借助链表遍历Get(i)子程序，我们现在可以如下实现向链表中间插入：
```java
Vertex pre = Get(i-1) // 遍历到第(i-1)个顶点， O(N)
aft = pre.next // aft 不能为null, 思考下
Vertex vtx = new Vertex(v) // 创建一个新的顶点
vtx.next = aft // 链接这个
pre.next = vtx // 以及这个
```
由于需要遍历列表（例如，如果i靠近N-1），则该操作很慢，时间复杂度为O（N）。

### 插入到tail后
如果我们还记得这个前面tail指针（这是可取的，因为它只是一个额外的指针变量），我们可以有效地执行在tail项后位置（i = N）插入，以O（1 ）实践复杂度：
```java
Vertex vtx = new Vertex(v) // 从v项创建一个新的顶点vtx
tail.next = vtx // tail是 i = (N-1)项，只需要链接到新的顶点
tail = vtx // 现在更新tail指针
```

## Remove(i)
***
对于remove(i),这有三种（合法）可能，也就是索引i为:
1. 链表的头部（当前第一个项），i=0，它影响head指针
2. 链表的尾部，i=N-1，它影响链表的tail指针
3. 链表其他位置， i = [1..N-2]

### 移除头部项
这种情况相当直观：
```java
Vertex temp = head // 我们可以稍后删除它
head = head.next // 更新头部指针
delete temp // 删除原来的head
```
### 移除尾部项
假设链接列表有多个项，我们可以执行如下删除链表的尾部：
```java
Vertex pre = head
temp = head.next
while (temp.next != null) // 当临近项不为tail时
  pre = pre.next, temp = temp.next // pre = Get(N-2), temp = Get(N-1)
pre.next = null
delete temp, tail = pre // temp = (old) tail,更新tail指针
```
实际上，如果我们还维护链表的尺寸N（与此幻灯片相比），我们可以使用链表遍历子程序Get(i)来实现链表尾部的删除：
```java
Vertex pre = Get(N-2) // 到tail前的索引处, 时间复杂度为O(N)
pre.next = null
delete tail, tail = pre // 可以访问旧的tail
```
请注意，这个操作很慢，为O（N），只是因为需要从N-1项向后一个单位更新tail指针到N-2项，以便之后在tail后插入依旧保持正确...这个缺陷将在后面的双向链表中得到解决。
### 移除中间项
借助链表遍历Get(i)子程序，我们现在可以实现移除链表中间项：
```java
Vertex pre = Get(i-1) //遍历到第(i-1) 个顶点, 时间复杂度为O(N)
Vertex del = pre.next, aft = del.next
pre.next = aft //绕过del
delete del
```

## 时间复杂度
***
- get(i)是比较慢：O（N）。 
- search(v) 
在最好的情况下，v在第一个位置找到,O（1）。
在最坏的情况下，列表中找不到v，我们需要扫描来确定，O（N）。
- insert(i，v) 
在最好的情况下，在i = 0或i = N插入，通过头尾指针帮助，需要O（1）。
在最坏的情况下，在i = N-1处插入，我们需要在尾部之前找到N-2项,O（N）。 
- remove(i)
在最好情况下，删除i = 0，在头指针帮助下，需要O（1）。 
在最坏的情况下，在i = N-1处删除，由于需要更新尾部指针，O（N）。

纯粹（单向）的链表应用程序是罕见的，因为更简单的可调整大小的紧凑型数组（vector）可以更好地完成工作，将链表版本与紧凑数组版本进行比较。
然而，链表的基本概念允许顶点在内存中不连续，这使其成为另外两个抽象数据类型的尺寸可调整的数据结构：**Stack**和**Queue**。

# Stack
