title: 排序（Sort）
id: 1505097809073
author: 不识
tags:
  - 排序
  - 算法
categories:
  - 算法
date: 2017-09-11 10:43:00
---


- 基于比较的排序算法（Comparison-based Sorting Algorithms）:
	- BUB - **冒泡排序**,
	- SEL - **选择排序**,
	- INS - **插入排序**,
	- MER - **合并排序**(递归实现),
	- QUI - **快速排序**(递归实现),
	- R-Q - **随机快速排序**(递归实现).
- 不基于比较的排序算法（Not Comparison-based Sorting Algorithms）:
	- COU - **统计排序**,
	- RAD - **基数排序**.

<!-- more -->
***
# 基于比较
***

##  冒泡排序（BublleSort）
***
给定一个N个元素的数组，冒泡排序将： 
1. 比较一对相邻元素（a，b）， 
2. 元素大小与不与顺序一致，交换元素， 
3. 重复步骤1和2，直到我们到达数组的结尾 （因为我们使用基于0的索引，最后一对是第（N-2）和（N-1）项） 
4. 到目前为止，最大的项目将在最后的位置。 
然后我们将N减少1，并重复步骤1，直到N = 1。

如上每次循环将最大值放到了最后，最坏情况下N个元素就将进行N-1次这样的循环，如下示例

1. 第1次迭代，到第N-2位置结束，总共需要N-1次比较交换，将最大值放到N-1位置
2. 第2次迭代，到第N-3位置结束，总共需要N-2次比较交换，将第二大值放到N-2位置
3. 第3次迭代，到第N-4位置结束，总共需要N-3次比较交换，将第三大值放到N-3位置
...
4. 第N-1次迭代，到第0位置结束，总共需要1次比较交换，将倒数第二大值放到1位置

这样总共需要的迭代次数为iterations = (N−1)+(N−2)+...+1 = N\*(N−1)/2，比较交换花的时间在常量时间c内，所以时间复杂度就等于 = c\*N\*(N−1)/2 = O(N^2)。但如果第一次迭代中就已经排好序，之后迭代就不再需要。容易发现，当内部迭代元素没有发生交换，说明已经实现排序完毕，结束操作，这种最好情况下时间复杂度将将为O(N)，Java实现代码如下：

```java
    public void bubbleSort(int[] array) {
        boolean swap = false;
        int l = array.length - 1;  // 数组长度-1，因为每次比较两个元素，最后一个不需要迭代
        for (int a = 0; a < l; a++) {  //外部每迭代一次，实现从一个该迭代中最大值位置放到最后
            for (int b = 0; b < l - a; b++) {  // 内部迭代次数为l - a，a可以理解已经排序好位置不变的元素个数
                int i = array[b];  //靠前元素
                int n = array[b + 1];  //靠后元素

                if (i > n) {
                    array[b] = (array[b + 1] = i) ^ (i ^ n); //实现两个元素交互位置
                    swap = true;
                }
            }
            if(swap == false) break; //等于false说明内部循环没有发生交换
        }
    }
```

##  选择排序（SelectionSort）
***
给定N个元素的数组，L = 0，选择排序将： 
1. 在[L ... N-1]的范围内找到最小元素X的位置
2. 交换X与第L项
3. 将下限L增加1并重复步骤1直到L = N-2

上述操作每次将迭代到的最小值放到前面，这样N元素将迭代N-1次，

1. 第1次迭代，从0位置开始，总共需要N-1次比较，找到最小值，将其交换到0位置
2. 第2次迭代，从1位置开始，总共需要N-2次比较，找到第二小值，将其交换到1位置
3. 第3次迭代，从2位置开始，，总共需要N-3次比较，找到第三小值，将其交换到2位置
...
4. 第N-1次迭代，从N-2位置开始，总共需要1次比较，找到倒数第二小值，将其交换到N-2位置

与冒泡排序类似，
```java
    public void selectionSort(int[] array) {
        int length = array.length - 1;
        for (int a = 0; a < length; a++) {
            int min = a;  
            for (int b = a; b < length; b++) {
                min = array[min] < array[b + 1] ? min : b + 1;  //获取最小元素的索引
            }
            int n = array[a];
            int m = array[min];
            array[a] = (array[min] = n) ^ (m ^ n);  //与当前循环最小元素互换
        }
    }
```
与冒泡排序一样，其时间复杂度也为O(N^2)。

##  插入排序（InsertionSort）
***
插入排序是从第二个元素开始，依次与前面的元素比较，一直比较到比它大的元素，就将它插入到该该元素之前。

```java
    public void insertionSort(){
        int a,b;
        for(a = 1;a < array.length; a++){ 
            int x = array[a];  // x是要插入的元素
            for(b = a -1 ;b >= 0 && array[b] > x; b--){ // array[b] > x表示往前迭代到一个比x大的值为止
                array[b + 1] = array[b];  //依次挪动前面的元素
            }
            array[b + 1] = x; //插入元素，之所以是b+1，是因为循环会最后执行一次b--
        }
    }
```

外循环执行N-1次，这很清楚。 
但内循环的执行次数取决外部循环位置：
- 在最佳情况下，数组已经被排序好，因为i（a [j]> X）总是为false 所以不需要数据的移动，内循环在O（1）中运行， 
- 在最坏情况下，数组是反向排序的，（a [j]> X）总是为true，始终需要在数组前插入，内部循环在O（N）中运行。

 因此，最佳情况时间为O（N×1）= O（N），最坏情况时间为O（N×N）= O（N2）。



