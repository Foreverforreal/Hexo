title: 排序（Sort）
id: 1505097809073
author: 不识
tags:
  - 排序
  - 算法
categories:
  - 算法
date: 2017-09-11 10:43:00
---


- 基于比较的排序算法（Comparison-based Sorting Algorithms）:
	- BUB - **冒泡排序**
	- SEL - **选择排序**
	- INS - **插入排序**
	- MER - **合并排序**(递归实现)
	- QUI - **快速排序**(递归实现)
	- R-Q - **随机快速排序**(递归实现)
- 不基于比较的排序算法（Not Comparison-based Sorting Algorithms）:
	- COU - **统计排序**
	- RAD - **基数排序**

<!-- more -->
***
# 基于比较的算法
***
-  **冒泡排序**
- **选择排序**
- **插入排序**
- **合并排序**(递归实现)
- **快速排序**(递归实现)
- **随机快速排序**(递归实现)
	
这些排序被称为基于比较的算法，因为它们比较一对数组元素，并决定是否交换它们。 前三个排序算法是最容易实现的，但也不是最有效的，因为它们在O（N2）时间复杂度中运行。

##  冒泡排序（BublleSort）
***
![冒泡排序](\images\datastructure\BubbleSort.gif)
给定一个N个元素的数组，冒泡排序将： 
1. 比较一对相邻元素（a，b）， 
2. 元素大小与不与顺序一致，交换元素， 
3. 重复步骤1和2，直到我们到达数组的结尾 （因为我们使用基于0的索引，最后一对是第（N-2）和（N-1）项） 
4. 到目前为止，最大的项目将在最后的位置。 
然后我们将N减少1，并重复步骤1，直到N = 1。

如上每次循环将最大值放到了最后，最坏情况下N个元素就将进行N-1次这样的循环，如下示例

1. 第1次迭代，到第N-2位置结束，总共需要N-1次比较交换，将最大值放到N-1位置
2. 第2次迭代，到第N-3位置结束，总共需要N-2次比较交换，将第二大值放到N-2位置
3. 第3次迭代，到第N-4位置结束，总共需要N-3次比较交换，将第三大值放到N-3位置
...
4. 第N-1次迭代，到第0位置结束，总共需要1次比较交换，将倒数第二大值放到1位置

这样总共需要的迭代次数为iterations = (N−1)+(N−2)+...+1 = N\*(N−1)/2，比较交换花的时间在常量时间c内，所以时间复杂度就等于 = c\*N\*(N−1)/2 = O(N^2)。但如果第一次迭代中就已经排好序，之后迭代就不再需要。容易发现，当内部迭代元素没有发生交换，说明已经实现排序完毕，结束操作，这种最好情况下时间复杂度将将为O(N)，Java实现代码如下：

```java
    public void bubbleSort(int[] array) {
        boolean swap = false;
        int l = array.length - 1;  // 数组长度-1，因为每次比较两个元素，最后一个不需要迭代
        for (int a = 0; a < l; a++) {  //外部每迭代一次，实现从一个该迭代中最大值位置放到最后
            for (int b = 0; b < l - a; b++) {  // 内部迭代次数为l - a，a可以理解已经排序好位置不变的元素个数
                int i = array[b];  //靠前元素
                int n = array[b + 1];  //靠后元素

                if (i > n) {
                    array[b] = (array[b + 1] = i) ^ (i ^ n); //实现两个元素交互位置
                    swap = true;
                }
            }
            if(swap == false) break; //等于false说明内部循环没有发生交换
        }
    }
```

##  选择排序（SelectionSort）
***
![选择排序](\images\datastructure\SelectionSort.gif)
给定N个元素的数组，L = 0，选择排序将： 
1. 在[L ... N-1]的范围内找到最小元素X的位置
2. 交换X与第L项
3. 将下限L增加1并重复步骤1直到L = N-2

上述操作每次将迭代到的最小值放到前面，这样N元素将迭代N-1次，

1. 第1次迭代，从0位置开始，总共需要N-1次比较，找到最小值，将其交换到0位置
2. 第2次迭代，从1位置开始，总共需要N-2次比较，找到第二小值，将其交换到1位置
3. 第3次迭代，从2位置开始，，总共需要N-3次比较，找到第三小值，将其交换到2位置
...
4. 第N-1次迭代，从N-2位置开始，总共需要1次比较，找到倒数第二小值，将其交换到N-2位置

与冒泡排序类似，
```java
    public void selectionSort(int[] array) {
        int length = array.length - 1;
        for (int a = 0; a < length; a++) {
            int min = a;  
            for (int b = a; b < length; b++) {
                min = array[min] < array[b + 1] ? min : b + 1;  //获取最小元素的索引
            }
            int n = array[a];
            int m = array[min];
            array[a] = (array[min] = n) ^ (m ^ n);  //与当前循环最小元素互换
        }
    }
```
与冒泡排序一样，其时间复杂度也为O(N^2)。

##  插入排序（InsertionSort）
***
![插入排序](\images\datastructure\InsertionSort.gif)
插入排序是从第二个元素开始，依次与前面的元素比较，一直比较到比它大的元素，就将它插入到该该元素之前。

```java
    public void insertionSort(){
        int a,b;
        for(a = 1;a < array.length; a++){ 
            int x = array[a];  // x是要插入的元素
            for(b = a -1 ;b >= 0 && array[b] > x; b--){ // array[b] > x表示往前迭代到一个比x大的值为止
                array[b + 1] = array[b];  //依次挪动前面的元素
            }
            array[b + 1] = x; //插入元素，之所以是b+1，是因为循环会最后执行一次b--
        }
    }
```

外循环执行N-1次，这很清楚。 
但内循环的执行次数取决外部循环位置：
- 在最佳情况下，数组已经被排序好，因为i（a [j]> X）总是为false 所以不需要数据的移动，内循环在O（1）中运行， 
- 在最坏情况下，数组是反向排序的，（a [j]> X）总是为true，始终需要在数组前插入，内部循环在O（N）中运行。

因此，最佳情况时间为O（N×1）= O（N），最坏情况时间为O（N×N）= O（N^2）。

##  归并排序（MergeSort）
***
### 算法
给定一个有N个项的数组，归并排序将： 
1. 将每对单个元素归并（排序）到2个元素的排序数组中， 
2. 将每对2个元素的排序数组合并为4个元素的排序数组， 重复这个过程...， 
3. 最后一步：合并2个N / 2个元素的排序数组（为了简单的讨论，我们假设N是偶数），以获得N个元素的完全排序的数组。

### 实现
这只是通用的想法，我们需要更多的细节，然后才能讨论合并排序的真实形式。要讨论归并排序算法，我们首先讨论它的最重要的子程序：O（N）合并。
给定两个大小为N1和N2的排序数组A和B，我们可以在O（N）时间内将它们有效地合并成一个大小为N = N1 + N2的较大组合排序的数组。这是通过简单地比较两个数组的前端并且始终采用两者中的较小的一个来实现的。此时，我们将需要额外的数组来正确地进行归并。以下为java实现：
```java
    public int[] merge(int[] left, int[] right) {
       int[] merge = new int[left.length + right.length];//额外归并数组

       int a = 0,l = 0,r = 0;
       while(l < left.length && r < right.length){
           meger[a++] = left[l] < right[r] ? left[l++] : right[r++]; //依次比较两个数组元素大小，小的放入归并数组
        }
        //如果两个数组大小不一，最后将剩余的那个全部放入归并数组
        while(l < left.length){
           meger[a++] = left[l++]; 
        }
        while(r < right.length){
            meger[a++] = right[r++];
        }
        return merge;
    }
```

在我们继续之前，让我们来谈谈分治法（Divide and Conquer），它是一个强大的问题解决范式，分治法将一个大的问题分为若干小的问题，分别解决每个小的问题，然后最后合并得出结果。
![归并排序](\images\datastructure\MergeSort.gif)
分治法算法可如下步骤解决排序问题：
- 分：将大小N的数组分成两部分
- 治：将两部分中的元素分别排序
- 归并：合并并排序分出的两部分的部分

上述O（N）合并实现代码中，需要两个部分数组的作为参数，而归并排序递归实现时不会真的拆分数组，而是通过传递数组索引来在一个数组中分割成各个部分，此外每次创建一个额外合并数组比较费时，我们采用传递重用一个临时数组，重写为下：
```java
    public void merge(int[] a, int first, int mid, int last, int[] temp) { // first和last为进行合并的数组两部分边界，mid为分割点，temp为临时数组存储排序合并结果
        int left = first, right = mid + 1, tIdx = 0;
		
        while (left <= mid && right <= last) {
            temp[tIdx++] = a[left] <= a[right] ? a[left++] : a[right++];
        }

        while (left <= mid) {
            temp[tIdx++] = a[left++];
        }
        while (right <= last) {
            temp[tIdx++] = a[right++];
        }
        for (int i = 0; i < tIdx; i++) {  //将排序好的两部分数据重新放回数组
            a[first + i] = temp[i];
        }
    }
```

以下为递归实现代码
```java
    public void mergeSort(int[] a,int first,int last, int[] temp){
        if(first < last){
            int mid = (first + last) / 2;  
            mergeSort(a,first,mid,temp);  //分割和排序数组左部分
            mergeSort(a,mid + 1,last,temp);//分割和排序数组右部分
            merge(a,first,mid,last,temp); //每次递归中，合并两部分元素
        }
    }
```
### 时间复杂度
在归并排序中，大部分的工作在治/合并步骤中，分的步骤并没有真正做什么（视为O（1））。当我们调用merge(a,first,mid,last,temp)，处理了 k = (high-low+1)项元素，这里有k-1次比较。从数组a到临时数组temp有k次移动，然后又有从数组temp移回数组a的k次操作，因此在merge中总共的操作次数是 < 3k-1 = O(k)。
而merge被调用的次数为：
![归并排序](\images\datastructure\merge.png)

Level 1: 2<sup>0</sup>=1 次调用merge()  ，每次合并 N/2<sup>1</sup> 项元素, O(2^0 x 2 x N/2<sup>1</sup>) = O(N)
Level 2: 2<sup>1</sup>=2 次调用 merge() ，每次合并 N/2<sup>2</sup> 项元素, O(2^1 x 2 x N/2<sup>2</sup>) = O(N)
Level 3: 2<sup>2</sup>=4 次调用 merge() ，每次合并 N/2<sup>3</sup> 项元素, O(2^2 x 2 x N/2<sup>3</sup>) = O(N)
...
Level (log N): 2<sup>(log N-1) </sup> (或 N/2)次调用 merge() ，每次合并 N/2<sup>log N </sup>)(或 1)项元素, O(N)

总共有log N级，并且在每一级我们执行O(N)的工作，因此总体的时间复杂度是O(N log N)，**稍后我们会看到这是一个最优的（基于比较的）排序算法，也就是没有比这更好的了**。

归并排序最重要的优点是无论输入的原始数组如何，其保证O（N log N）性能。就是这样，对于任何N个元素数组的，没有任何对手测试用例可以使归并排序运行的时间超过O（N log N）。因此，归并排序非常适合排序极大数量的输入，因为O（N log N）比我们之前讨论的O（N2）排序算法花费时间增长慢得多。 

然而，合并排序也有几个不太好的部分。首先，从头开始实际上不容易实现（但是我们不需要去实现）。第二，在合并操作期间需要额外的O（N）存储，因此不会真正具有高效的内存。

## 快速排序（QuickSort）
***
快速排序是另一个分治排序算法。在学习随机和可用版本的快速排序算法前，我们首先看下一种确定性的，非随机的快速排序版本可能会有一个坏的时间复杂度O(N2)。
### 算法
分割步骤：选择一个项p（称为支点(pivot)） 
然后将a[i..j]的项分成三部分：a [i..m-1]，a [m]和[m + 1..j]。 
a [i..m-1]（可能为空）包含小于p的项。 
a [m]是支点p，即索引m是p在排序数组中的正确位置
a [m + 1..j]（可能为空）包含大于或等于p的项目。
然后，递归地排序这两个部分。 
 
征服步骤：不要惊讶...我们什么都不做：哦！ 
如果将其与归并排序进行比较，您将看到Quick Sort D＆C步骤与Merge Sort完全相反。

### 实现
我们首先通过讨论快速排序最重要的子程序：O（N）分区。
为了分割一个数组a[i..j]，我们首先选择一个a[i]作为支点p。 其余项（即a[i + 1..j]）分为3个区域： 
1. S1区域  a [i + 1..m]其中项<p， 
2. S2区域  a [m + 1..k-1]其中项≥p
3. 未知区域 a [k..j]，其中项尚未分配给S1或S2。 

最初，S1和S2区都是空的，也就是除了指定的支点p之外的所有项都处于未知区域。 
然后，对于未知区域中的每个项a[k]，我们将a[k]与p进行比较，并确定以下两种情况之一： 
1. 如果a[k]≥p，则将a[k]置于S2 
2. 否则，将a[k]置入S1。 

最后，我们交换a[i]和a[m]，以使p在S1和S2的中间。
![划分1](\images\datastructure\partition1.png)
![划分2](\images\datastructure\partition2.png)
该部分java实现代码为：
```java
    public int partition(int a[], int i, int j) {
        int p = a[i];// 支点p
        int m = i; // S1与S2区域分割处

        // 推进k，探索未知区域
        for(int k = i + 1;k < j; k++){ 
            if(a[k] < p){ //小于支点则m++来拓展S1区域，并将k置于S1中
                m++;
                a[m] = (a[k] ^ a[m]) ^ (a[k] = a[m]);
            }
        }
        a[m] = (a[i] ^ a[m]) ^ (a[i] = a[m]);// 最后将支点p与m处交换
        return m;
    }
```
递归实现快速排序：
```java
    public void quickSort(int[] a, int first, int last){
        if(first < last){
            int m = partition(a,first,last);
            quickSort(a,first,m - 1);  //每次递归中排序m左边的元素
            quickSort(a,m + 1,last); //每次递归中排序m右边的元素
        }

    }
```
![快速排序](\images\datastructure\QuickSort.gif)
我们将详细说明第一个分区步骤如下： 
我们设置p = a[0] = 27。 
我们设置一个a[1] = 38作为S2的一部分，所以S1 = {}和S2 = {38}。 
我们用a[2] = 12交换a[1] = 38，所以S1 = {12}和S2 = {38}。 
我们设置一个a[3] = 39，后来a[3] = 27作为S2的一部分，所以S1 = {12}，S2 = {38,39,27}。 
我们用a[5] = 16交换a[2] = 38，所以S1 = {12,16}和S2 = {39,27,38}。 
我们用a[2] = 16交换p = a [0] = 27，所以S1 = {12,16}，p = {27}，S2 = {39,27,38}。 

之后，a[2] = 27被保证被排序，现在Quick Sort递归地对左边a[0..1]进行排序，然后递归地排序右边的一个a[3..5]。

### 时间复杂度
首先，我们分析一次调用partition的成本。 在partition（a，i，j）中，只有一个循环遍历（j-i）次。由于j可以和N-1一样大，i可以低至0，所以partition的时间复杂度为O（N）。类似于合并排序分析，快速排序的时间复杂度取决于调用partition（a，i，j）的次数。

当数组a已经按照升序排列，就像上面的例子一样，快速排序将设置p = a [0] = 5，并返回m = 0，从而使S1区域为空，S2区域包含除了支点[N-1]外的其他元素。 在这种最糟糕的情况下：
![快速排序最坏情况](\images\datastructure\qsort_worstcase.png)
第一个partition耗费O（N）时间，将a分为0，1，N-1项，然后递归。 
第二个耗费O（N-1）时间，将a分为0，1，N-2项，然后再次递归。 
... 直到最后，第N个分区将a分为0,1,1个项目，并且快速排序递归停止。 

这是经典的N +（N-1）+（N-2）+ ... + 1模式，它是O（N2）...

快速排序的最佳情况是当分区总是将阵列分成两个相等的两部分时，这就像归并排序。 当这种情况发生时，递归的深度是log n。当每个级别进行O（N）比较时，时间复杂度为O（N log N）。 但在实践中，这是罕见的，因此我们需要设计一个更好的方法：随机快速排序。

## 随机快速排序（Random QuickSort）
***
与快速排序相同，只是在执行分区算法之前，它随机选择[low..high]之间的支点，而不是总是选择a[first]。 
要解释为什么这个随机版本的Quick Sort可以对N个元素的任何数组上，有预期O（N log N）的时间复杂度，这需要1个小时的讲解，但在这里，我们假设是真的。 如果需要非正式的解释：想象一下随机版本的Quick Sort，它将支点的选择随机化，我们不会总是得到最坏的分区0（空），1（支点）和N-1个其他项。这种最好（一半-支点-一半），次好，不好，非常好（空-支点-其余的）的组合产生了O（N log N）时间复杂度的平均时间复杂度。

***
# 不基于比较的算法
***
- **统计排序**,
- **基数排序**.

通过不比较数组的元素，这些排序算法可以比Ω（N log N）的基于比较的排序算法的下限更快。
它是已知的（这里没有证明，因为这将需要另外1个小时的讲座），所有基于比较的排序算法具有Ω（N log N）的下限时间复杂度。因此，任何基于比较的算法具有最差情况下O（N log N）时间复杂度，（如归并排序）被认为是一种最佳算法，也就是已经无法再优化。然而，如果存在输入数组的某些假设，因此我们可以避免比较元素以确定排序顺序，所以我们可以实现更快的排序算法，即O（N）。


## 统计排序（Counting Sort）
***
假设：如果要排序的项 是小范围的整数，我们可以计算每个整数的出现频率（在该小范围内），并循环通过该小范围以排序顺序输出项。

在一个所有整数在[1...9]范围的示例数组上进行统计排序，我们只需要计算整数1出现多少次，整数2多少次， ..., 整数9多少次，然后如果频率[y] = x，则从1到9循环打印出整数y的x个副本。 时间复杂度是O（N），计算频率操作花费O（k），其中k是输入整数的范围，在该示例中为9-1 + 1 = 9。统计排序的时间复杂度是O（N + k），如果k是（非常）小的话，则为O（N）。
 由于内存限制，当k相对较大时，我们将无法进行统计排序的统计部分。
 
 
## 基数排序（Radix Sort）
***
假设：如果要排序的项是具有较大范围的整数，我们可以将统计排序思想与基数排序相结合，以实现线性时间复杂度。

在基数排序中，我们将每个项视为一个d位数字的字符串排序（如果需要，在少于d位的整数前放置0）。 对于最低位（最右边）到最高位（最左边），我们通过N个项目，并将它们根据活动数字放入10个队列（每个数字[0..9一个]），这就像改进的统计排序，因为这保持稳定性。然后，我们再次重新连接组，以便后续的迭代。 

注意，我们只执行O（d×（N + k））次迭代。在这个例子中，d = 4和k = 10。

***
# 排序算法的其他属性
***
还有一些其他属性可用于区分排序算法，无论是基于比较还是不基于比较，递归或迭代。 在本节中，我们将讨论in-place和非in-place，稳定vs不稳定，以及缓存排序算法的性能。


## In-place排序
***
如果排序算法在排序过程中仅需要常量（即O（1））的额外空间，则排序算法被称为in-place排序算法。就是这样，一些常量的额外的变量是可以的，但是我们不允许根据输入大小N而有可变长度的变量。 归并排序，由于其合并子程序，需要额外的大小为N的临时数组，所以是非in-place的。 

## 稳定排序
***
如果在排序执行后，算法保留具有相同键值的元素的相对顺序，则排序算法称为稳定。 

稳定排序的示例应用：假设我们有按字母顺序排列的学生姓名。现在，如果这个列表按教程组号重新排序（回想一个教程组通常有很多学生），一个稳定的排序算法将确保同一教程组中的所有学生仍然按照名称的字母顺序显示。 

前面算法中稳定排序有：冒泡排序，插入排序，归并排序，统计排序，基数排序
不稳定排序有：选择排序，快速排序